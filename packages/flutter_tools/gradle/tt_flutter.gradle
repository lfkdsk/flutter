import java.lang.reflect.Field
import java.nio.file.Path
import java.nio.file.Paths

import com.android.builder.model.AndroidProject
import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.Task
import org.gradle.api.file.CopySpec
import org.gradle.api.file.FileCollection
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.bundling.Jar

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarInputStream
import java.util.jar.JarOutputStream

import com.android.build.gradle.api.ApkVariant
import com.android.build.gradle.internal.ide.ArtifactDependencyGraph
import com.android.build.gradle.internal.tasks.AppPreBuildTask
import com.android.builder.model.Dependencies
import com.android.builder.model.SyncIssue
import com.google.common.collect.ImmutableMap
import org.gradle.api.artifacts.transform.ArtifactTransform
import org.gradle.api.Project

import java.util.function.Consumer
import org.apache.commons.io.FileUtils

buildscript {
    repositories {
        google()
        jcenter()
        maven {
            url 'https://dl.google.com/dl/android/maven2'
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
    }
}

apply plugin: FlutterPatchPlugin

class FlutterPatchPlugin implements Plugin<Project> {
    private Properties localProperties
    private File flutterRoot
    private File debugFlutterJar
    private File profileFlutterJar
    private File releaseFlutterJar
    private File dynamicProfileFlutterJar
    private File dynamicReleaseFlutterJar
    private String targetArch
    static final String flutterBuildPrefix = "flutterBuild"


    @Override
    void apply(Project project) {
        String flutterRootPath = resolveProperty(project, "flutter.sdk", System.env.FLUTTER_ROOT)
        if (flutterRootPath == null) {
            throw new GradleException("Flutter SDK not found. Define location with flutter.sdk in the local.properties file or with a FLUTTER_ROOT environment variable.")
        }
        flutterRoot = project.file(flutterRootPath)
        if (!flutterRoot.isDirectory()) {
            throw new GradleException("flutter.sdk must point to the Flutter SDK directory")
        }

        Path baseEnginePath = Paths.get(flutterRoot.absolutePath, "bin", "cache", "artifacts", "engine")
        targetArch = 'arm'
        if (project.hasProperty('target-platform') &&
                project.property('target-platform') == 'android-arm64') {
            targetArch = 'arm64'
        }
        String liteSuffix = ''
        if (project.hasProperty('lite') && project.property('lite').toBoolean()) {
            liteSuffix = '-lite'
        }
        debugFlutterJar = baseEnginePath.resolve("android-${targetArch}${liteSuffix}").resolve("flutter.jar").toFile()
        profileFlutterJar = baseEnginePath.resolve("android-${targetArch}-profile${liteSuffix}").resolve("flutter.jar").toFile()
        releaseFlutterJar = baseEnginePath.resolve("android-${targetArch}-release${liteSuffix}").resolve("flutter.jar").toFile()
        dynamicProfileFlutterJar = baseEnginePath.resolve("android-${targetArch}-dynamic-profile${liteSuffix}").resolve("flutter.jar").toFile()
        dynamicReleaseFlutterJar = baseEnginePath.resolve("android-${targetArch}-dynamic-release${liteSuffix}").resolve("flutter.jar").toFile()

        Set<String> excludesFiles = new HashSet<>()

        if (project.hasProperty("EXCLUDE_FLUTTER_JAR_FILES")) {
            String excludesStr = project.property("EXCLUDE_FLUTTER_JAR_FILES")
            if (excludesStr != null) {
                excludesFiles.addAll(excludesStr.split(',').toList())
            }
        }
        File pluginsFile = new File(project.projectDir.parentFile.parentFile, '.flutter-plugins')
        Properties plugins = readPropertiesIfExist(pluginsFile)

        plugins.each { name, _ ->
            def pluginProject = project.rootProject.findProject(":$name")
            if (pluginProject != null) {
                // 解析需要自定义的类，从jar中排除
                if (pluginProject.hasProperty("EXCLUDE_FLUTTER_JAR_FILES")) {
                    String excludesStr = pluginProject.property("EXCLUDE_FLUTTER_JAR_FILES")
                    if (excludesStr != null) {
                        excludesFiles.addAll(excludesStr.split(',').toList())
                    }
                }
            } else {
                project.logger.error("Plugin project :$name not found. Please update settings.gradle.")
            }
        }
        
        if (project.hasProperty('localEngineOut')) {
            String engineOutPath = project.property('localEngineOut')
            File engineOut = project.file(engineOutPath)
            File flutterJar = Paths.get(engineOut.absolutePath, "flutter.jar").toFile()
            createJarContainsArmeabi(flutterJar, excludesFiles)
        }

        createJarContainsArmeabi(debugFlutterJar, excludesFiles)
        createJarContainsArmeabi(profileFlutterJar, excludesFiles)
        createJarContainsArmeabi(releaseFlutterJar, excludesFiles)

    }

    private File getFlutterJar(buildType) {
        String buildMode = buildModeFor(buildType)
        if (buildMode == "debug") {
            debugFlutterJar
        } else if (buildMode == "profile") {
            profileFlutterJar
        } else {
            releaseFlutterJar
        }
    }

    private static String buildModeFor(buildType) {
        if (buildType.name == "profile") {
            return "profile"
        } else if (buildType.name == "dynamicProfile") {
            return "dynamicProfile"
        } else if (buildType.name == "dynamicRelease") {
            return "dynamicRelease"
        } else if (buildType.debuggable) {
            return "debug"
        }
        return "release"
    }

    private void createJarContainsArmeabi(File file, Set<String> excludesFiles) {
        // flutter_origin.jar为原文件的备份
        File originFile = new File(file.getParent() + File.separator + "flutter_origin.jar")

        JarFile flutterJarFile = new JarFile(file)
        // 说明是新的flutter.jar，需要重新复制flutter_origin.jar
        if (flutterJarFile.getJarEntry("lib/armeabi/libflutter.so") == null) {
            FileUtils.copyFile(file, originFile)
        } else {
            // 已经是处理好的jar了
            if (excludesFiles.isEmpty()) {
                return
            }
        }

        String path = file.path
        file.delete()
        File result = new File(path)

        JarFile jarFile = new JarFile(originFile)
        JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(result))
        JarInputStream jarInputStream = new JarInputStream(new FileInputStream(originFile))
        JarEntry jarEntry
        // copy所有文件，同时排除gradle.properties中排除的文件
        while ((jarEntry = jarInputStream.nextJarEntry) != null) {
            if (!jarEntry.isDirectory() && (excludesFiles == null || !excludesFiles.any {
                jarEntry.name.startsWith(it.trim())
            })) {
                jarOutputStream.putNextEntry(jarEntry)
                copyStream(jarFile.getInputStream(jarEntry), jarOutputStream)
                jarOutputStream.closeEntry()
            }
        }

        if (targetArch == 'arm' && jarFile.getJarEntry("lib/armeabi/libflutter.so") == null) {
            jarEntry = jarFile.getJarEntry("lib/armeabi-v7a/libflutter.so")
            jarOutputStream.putNextEntry(new JarEntry("lib/armeabi/libflutter.so"))
            copyStream(jarFile.getInputStream(jarEntry), jarOutputStream)
            jarOutputStream.closeEntry()
        }
        jarOutputStream.close()
        jarInputStream.close()
        jarFile.close()
    }


    private static void copyStream(InputStream input, OutputStream output) throws IOException {
        byte[] bytes = new byte[2048]
        int bytesRead
        while ((bytesRead = input.read(bytes)) != -1) {
            output.write(bytes, 0, bytesRead)
        }
    }


    private Properties readPropertiesIfExist(File propertiesFile) {
        Properties result = new Properties()
        if (propertiesFile.exists()) {
            propertiesFile.withReader('UTF-8') { reader -> result.load(reader) }
        }
        return result
    }

    private String resolveProperty(Project project, String name, String defaultValue) {
        if (localProperties == null) {
            localProperties = readPropertiesIfExist(project.rootProject.file('local.properties'))
        }
        String result
        if (project.hasProperty(name)) {
            result = project.property(name)
        }
        if (result == null) {
            result = localProperties.getProperty(name)
        }
        if (result == null) {
            result = defaultValue
        }
        return result
    }

    void writeFile(InputStream is, File file) throws Exception {
        if (file != null) {
            OutputStream os = new BufferedOutputStream(new FileOutputStream(file))
            byte[] bytes = new byte[2048]
            int len
            while ((len = is.read(bytes)) != -1) {
                os.write(bytes, 0, len)
            }
            os.close()
        }
    }
}


